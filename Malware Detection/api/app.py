import os
import re
import json
import pandas as pd
from fastapi import FastAPI, File, UploadFile
from fastapi.responses import JSONResponse
from joblib import load
from pyaxmlparser import APK
import xml.etree.ElementTree as ET

# Load the pre-trained model
rf = load("malware_detection.joblib")

# Load the feature categories from the JSON file
with open("features-categories.json", "r") as f:
    features_json = json.load(f)

# Create FastAPI app
app = FastAPI()

# Helper function to extract features from the APK file using pyaxmlparser
def extract_features(apk_file_path):
    # Using pyaxmlparser to parse the APK file
    apk = APK(apk_file_path)

    # Extract permissions from the manifest
    permissions = apk.get_permissions()
    found_permissions = [permission.split(".")[-1] for permission in permissions if permission.split(".")[-1] in features_json["Manifest Permission"]]

    # Extract intents from the manifest using pyaxmlparser
    manifest_xml = apk.get_android_manifest_xml()  # Get the raw XML of the manifest
    root = ET.fromstring(ET.tostring(manifest_xml))  # Convert XML element to string and parse
    
    found_intents = []
    # Iterate over <intent-filter> elements in the manifest
    for intent_filter in root.findall(".//intent-filter"):
        for action_element in intent_filter.findall(".//action"):
            action_value = action_element.get("{http://schemas.android.com/apk/res/android}name")
            for intent in features_json["Intent"]:
                if re.search(intent, action_value):
                    found_intents.append(intent)

    # Extract keywords (if applicable)
    found_keywords = []  # Customize this part if needed

    # Prepare feature vector for prediction
    features = {}
    for permission in features_json["Manifest Permission"]:
        features[permission] = 1 if permission in found_permissions else 0
    for intent in features_json["Intent"]:
        features[intent] = 1 if intent in found_intents else 0
    for keyword in features_json["Commands signature"]:
        features[keyword] = 1 if keyword in found_keywords else 0

    # Convert features dictionary to a pandas DataFrame
    test_df = pd.DataFrame([features])

    return test_df

@app.post("/predict")
async def predict(apk_file: UploadFile = File(...)):
    try:
        # Save the uploaded APK file to a temporary location
        apk_file_path = f"temp_{apk_file.filename}"
        with open(apk_file_path, "wb") as f:
            f.write(await apk_file.read())

        # Extract features from the uploaded APK file
        test_df = extract_features(apk_file_path)

        # Ensure the feature DataFrame matches the model's expected format
        model_columns = rf.feature_names_in_  # Get feature names from the model
        missing_cols = set(model_columns) - set(test_df.columns)

        # Add missing columns with a default value of 0
        for col in missing_cols:
            test_df[col] = 0

        # Reorder the columns to match the model's expected feature order
        test_df = test_df[model_columns]

        # Ensure there are no NaN values
        test_df = test_df.fillna(0)

        # Predict the class (benign or malware)
        prediction = rf.predict(test_df)

        result = "Malware" if prediction[0] == 1 else "Benign"

        # Delete the temporary file
        os.remove(apk_file_path)

        return JSONResponse(content={"result": result})

    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
